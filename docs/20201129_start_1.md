Yet Another Bare metal Rust adventure
=====================================

Introduction
------------

I bought a book Minix 3 to learn an OS which POSIX compliant is put together. This book is veryu nice to read, because it so technical and quite easy to understand how it all fits together in x86. So this is a journey to kind a port the minix 3 onto a Raspberry Pi 4 and the micro-kernel completely written in Rust.
Here I'll describe the experiences I had and didn't had.
The blog will be written as a combination of Aarch64 Assembly, C/C++ and Rust. Why is not only Rust? Because you need sometimes to interact quite low-level and here assembly will help a lot. The C/C++ knowledge is to investigate how it is done in C, before we go to Rust. We'll learn Rust a long the way, so sometimes test programs are written in C to verify if it all works in another. 

### ARM, Thumb, Aarch32, Aarch64

I will be honest, I can't follow these ISA's anymore, because I thing I came by conclusion by practical experience: arm assembly does not transform with the Aarch64 assembler. Probably normal, but I was surprised anyway. So I focus here on Aarch64 and the other ISA's is second importance to me.

### IDE ?

As main IDE, I'll be using SublimeText 3 with the Rust extension. Why? Because I'm used to it. So I advice to use a good IDE with a Rust extension, C/C++ extension and maybe (if supported) Aarch64 assembler extension.

Adventure 1: Burning a LED
--------------------------

### Introduction

All beginning is difficult and it took 4 days to let a LED burning on Raspberry Pi 4. Probably you already don it in 5 minutes on the Pi using python. True, but how do we do it in Rust and in bare metal. I also had to learn the hardware of the Pi and the address ranges. When you look at ["Bare Metal Programming on Raspberry Pi 3"](https://github.com/bztsrc/raspi3-tutorial) (Pi3OS) it looks easy, but it doesn't work on Pi4, only on a Pi 3. If you read ["Baking Pi â€“ Operating Systems Development"](https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/) (BakingPiOS), again he builds up the assembly course very great, but it doesn't work on Pi3 and 4. Even the assembly doesn't transpile with Aarch64 assembler... Here you'll see why.

### Setup your development environment

I explained we'll be working in 3 languages: Rust, C/C++ and Aarch64 assembly.
Start with the directory structure. You're in your workspace directory. Mine is /home/david/workspacehd

```
mkdir ruspi-devenv
cd ruspi-devenv
mkdir devkit
mkdir devkit-build
cd devkit-build
```
I'll try not to mess up your environment with installing stuff on your linux system. But this also applies to create nice docker images.

#### The Aarch64 assembler
We start with the assembler for Aarch64. You need to download the latest ['binutils'](https://ftp.gnu.org/gnu/binutils/) (binutils) from the GNU ftp server . Whe the latest, because it is the greatest ;-).

```
wget https://ftp.gnu.org/gnu/binutils/binutils-2.34.tar.bz2
wget https://ftp.gnu.org/gnu/binutils/binutils-2.34.tar.bz2.sig
```

I'm a security engineer, so let's verify the signature on the package.

```
gpg --verify ./binutils-2.34.tar.xz.sig
```

Ooeps error, probably can't verify the signature, because you don't have the signers public key. OK, let's retrieve the public:

```
gpg --keyserver hkp://keys.gnupg.net --recv-keys 13FCEF89DD9E3C4F
```

You have retrieved the public key, but he's not your friend (part of webtrust). So you're left with a warning. You should go and check his profile on the internet to see if it fits. If so, you can accept the warning. At the end, he is probably not your friend. If he is, the better, becasue he does a great job maintaining 'binutils'. If you want to be his friend you need to signhis key, but here I stop about explaining PGP ...

```
gpg --verify ./binutils-2.34.tar.xz.sig
```

We ignore the warning, because we check on the internet the maintainers name and looked up his public key in a directory service (at Mozilla for example). You have to perform these steps also with the GCC compiler.

We start compiling the assembler and linker and all other binary utilities to verify binary executables.

```
tar xvf ./binutils-2.34.tar.xz
rm binutils-2.34.tar.*
mkdir binutils-build
cd binutils-build
./binutils-2.34/configure --prefix=/home/david/workspacehd/ruspi-devenv/devkit --program-prefix=aarch64-none-elf- --target=aarch64-none-elf --disable-nls
```

We use the 'aarch64-none-elf' triple as a target, which means we target the Aarch64 processor, we don't target an OS (you can if you want to) and we're creating ELF binaries. Which we can easily execute with the raspi3 emulator of QEMU. The binutils will be installed under the devkit, such that we remove the devkit-build afterwards. TODO: Make a docker image, dude!

```
make
```

It's time for a coffee.
 
After the build, we check the build and install the binutils in devkit directory.

```
make check
make install
```

Now we cleanup the binutils directory. You don't have to, because you can empty the binutils-build directory and build to cross-compile tools for arm Aarch32 for example.

#### The Aarch64 GCC compiler

Here we build the [gcc compiler](https://ftp.gnu.org/gnu/gcc/) (gcc). You will have an error here that the 'libcc1' is not build, which you can ignore. We're doing bare metal here and I didn't need it. 

- Download it and verify the signature:
```
wget https://ftp.gnu.org/gnu/gcc/gcc-10.2.0/gcc-10.2.0.tar.xz
wget https://ftp.gnu.org/gnu/gcc/gcc-10.2.0/gcc-10.2.0.tar.xz.sig
gpg --verify ./gcc-10.2.0.tar.xz.sig
gpg --keyserver hkp://keys.gnupg.net --recv-keys 7F74F97C103468EE5D750B583AB00996FC26A641
```

- We'll configure the gcc toolchain for Aarch64
```
tar xvf ./gcc-10.2.0.tar.xz
rm gcc-10.2.0.tar.*
mkdir gcc-build
cd gcc-build
../gcc-10.2.0/configure --prefix=/home/david/workspacehd/ruspi-devenv/devkit/ --program-prefix=aarch64-none-elf- --target=aarch64-none-elf --disable-nls --without-headers --with-newlib --disable-multilib --with-as=/home/david/workspacehd/ruspi-devenv/devkit/bin/aarch64-none-elf-as --with-ld=/home/david/workspacehd/ruspi-devenv/devkit/bin/aarch64-none-elf-ld --enable-languages=c
```

These are a lot of options and it is an exercise for you to figure out what they all mean, at the end is it bare metal and no libc is necessary here. We only need a compiler to create Aarch64 binary blobs to run on a Raspberry Pi 4 without an OS installed.

- At last we start the compilation and you can go to breakfast, lunch, dinner or to sleep depending the time of day.
```
make all-gcc
```

- We verify the build, where we get the error of the libcc1 not found. You see at the end it said cc1 not enable, but still he'll check it.
```
make check all-gcc
make install-gcc
```

**Troublshoot:** If something goes wrong, clean the build-directory and verify the commands you copied. Or search on the internet which package you're missing.

Create a file to setup your devkit environment:

- Go back to your ruspi-devenv directory
```
cd ../..
```
- create a 'setenv.sh' file with content, you could also chang the prompt.
```
#!/bin/sh
export PATH=$(pwd)/devkit/bin:$PATH
```

You can use the 'source' command to load setenv.sh parameters or make it executable with **chmod**
```
source setenv.sh
```

#### Test your devkit assembler

I'm not going to explain what the program does. You are going to need a Raspberry Pi4 and an sdcard with raspbian-lite, which is not vital. We are going to overwrite the kernel8.img file!!! This is your test sdcard!!! Don't use your Raspberry Pi home entertainment sdcard!!!

You're in your .../ruspi-devenv directory

- So run:
```
source setenv.sh
aarch64-none-elf-as --version
```
You should see a version being prompted.

- Create the ruspi-lab or clone it from github.
```
mkdir -p ruspi-lab/01_shine-in-darkness-assembly
cd ruspi-lab/01_shine-in-darkness-assembly
```

- Copy following copy into **main.s**
```
// AArch64 mode
 
// This file will be kept as first (see linker script).
.section ".text.start"
 
// Make _start global.
.globl _start
 
_start: 
    // Stop all cores except core 0
    mrs     x1, mpidr_el1
    and     x1, x1, #3
    cbz     x1, 2f
1:   
    wfe
    b       1b

2:
    ldr     x5, =_start
    mov     sp, x5
 
    // clear bss
    ldr     x5, =__bss_start
    ldr     w6, =__bss_size
3:  cbz     w6, 4f
    str     xzr, [x5], #8
    sub     w6, w6, #1
    cbnz    w6, 3b
 
    // GPIO location of the Raspberry Pi 4 (a Raspberry Pi 3 is 0x3F20000)
4:  ldr     x19, =0xFE200000

    // Set GPIO pin 21 as output
    mov     w0, #21
    mov     w1, #1
    bl      SetGpioFunc

    // Set GPIO PIN 21 to high, light a LED
    mov     w0, #21
    mov     w1, #1
    bl      SetGpioSet
    // Stop the core
    b       1b

    // Set GPIO pin x0 as defined function in x1
SetGpioFunc:
    // Paramater checking
    cmp     w0, #28
    //  if previous cmp (lt) is true we compare w1 with #8, if true set #nzcv for #4 (enable Z-flag)
    ccmp     w1, #8, #4, lt
    b.ge    SetGpoiFunc_ret

    // FSel0 ?
    cmp     w0, #10
    b.ge    SetGpoiFunc_sel1
    mov     w2, #3
    mul     w0, w0, w2
    ldr     w2, [x19, #0x00]
    mov     w3, #7
    lsl     w3, w3, w0
    mvn     w3, w3
    and     w2, w2, w3
    lsl     w1, w1, w0
    orr     w1, w1, w2
    str     w1, [x19, #0x00]
    ret

SetGpoiFunc_sel1:
    // FSel1 ?
    cmp     w0, #20
    b.ge    SetGpoiFunc_sel2
    sub     w0, w0, #10
    mov     w2, #3
    mul     w0, w0, w2
    ldr     w2, [x19, #0x04]
    mov     w3, #7
    lsl     w3, w3, w0
    mvn     w3, w3
    and     w2, w2, w3
    lsl     w1, w1, w0
    orr     w1, w1, w2
    str     w1, [x19, #0x04]
    ret

SetGpoiFunc_sel2:
    // FSel2 ?
    sub     w0, w0, #20
    mov     w2, #3
    mul     w0, w0, w2
    ldr     w2, [x19, #0x08]
    mov     w3, #7
    lsl     w3, w3, w0
    mvn     w3, w3
    and     w2, w2, w3
    lsl     w1, w1, w0
    orr     w1, w1, w2
    str     w1, [x19, #0x08]

SetGpoiFunc_ret:
    ret

    // Set GPIO pin x0 to output value x1 (on/off)
SetGpioSet:
    // Paramater checking
    cmp     w0, #28
    //  if previous cmp (lt) is true we compare w1 with #2, if true set #nzcv for #4 (enable Z-flag)
    ccmp    w1, #2, #4, lt
    b.ge    SetGpoiSet_ret

    mov     w2, #1
    lsl     w2, w2, w0
    // LED off or on ?
    cmp     w1, #1
    b.ge    SetGpoiSet_on
    // LED off
    str     w2, [x19, #0x28]
    ret
SetGpoiSet_on:
    str     w2, [x19, #0x1C]

SetGpoiSet_ret:
    ret

```

- make a **linker.ld** file for the linking stage with the content:
```
ENTRY(_start)


SECTIONS
{
    . = 0x80000;
    .text :
    {
        KEEP(*(.text.start))
        *(.text)
    }
    . = ALIGN(32); /* align to page size */
 
    .rodata :
    {
        *(.rodata)
    }
    . = ALIGN(32); /* align to page size */
 
    .data :
    {
        *(.data)
    }
    . = ALIGN(32); /* align to page size */
 
    __bss_start = .;
    .bss :
    {
        bss = .;
        *(.bss)
    }
    . = ALIGN(32); /* align to page size */
    __bss_end = .;
    __bss_size = __bss_end - __bss_start;
}
```

- make a **config.txt** file for your Raspberry to start in 64 bit mode:
```
arm_64bit=1
uart_2ndstage=1
dtoverlay=miniuart-bt
```

Explanation of the settings come later in follow up chapters, this is just to test your assembler and let a light shine.

- Run the assembler, linker and create your very first kernel
```
aarch64-none-elf-as -c main.s -o main.o
aarch64-none-elf-ld -T linker.ld -o main.elf main.o
aarch64-none-elf-objcopy -O binary main.elf kernel8.img
```

We've build our first Raspberry Pi 4 kernel. And if you want to make a **Makefile**, just do it. It is just a test here.

- Insert your raspbian-lite sdcard, it should normally map to /media/XXXYYYY/boot and /media/XXXYYYY/rootfs
- Copy the **config.txt** and **kernel8.img** to the sdcard under the directory /media/XXXYYYY/boot. The Raspbian will not boot anymore!!!! Or you have to restore the 2 files.
```
cp config.txt /media/david/boot
cp kernel8.img /media/david/boot
sync
```

- Connect a LED to [Raspberry's GPIO](https://www.raspberrypi.org/documentation/usage/gpio/) (GPIO) pin 21 (see diagram and photo)
  - connect a resistor of around 1k to GPIO 21 (pin 40 on the connection)
  - connect the positive leg of the LED to the resistor (that's the longest if it hasn't been cut off)
  - connect the negative leg of the LED to the ground on the GPIO (like pin 14 on the connector)

![Raspberry Pi 4 circuit!](/assets/images/shining-in-dark-circuit1.png?raw=true "Shining in dark circuit")

![Raspberry Pi 4 picture!](/assets/images/shining-in-dark-picture1.jpg?raw=true "Shining in dark layout")

*Note 1:* Use an electronics test board
*Note 2:* Verify the documentation of the GPIO pin layout!!!! It can break your board.

- Insert the card into the Raspberry Pi 4 and start it. You don't need a monitor or keyboard attached.

![Raspberry Pi 4 with LED!](/assets/images/shining-in-dark-picture2.jpg?raw=true "Shining in dark")


#### Rust for Aarch64

For rust it is quite easy, because it download a toolchain when you start the cargo build process. It stores it in your target directory. You have to create a project with the Aarch64 support with cargo.
Install Rust using the explanation of the rust-lang.org website. Then you have to switch to the 'nightly'-version for the aarch64 support. 

- First update you're rust toolchain to the latest version
```
rustup update 
```

- Swithch to the 'nightly' and update again
```
rustup default nightly
rustup update 
```

When the aarch64 support is in the stable release, you don't need to use the 'nightly' ofcourse.




### Setup your testing environment

Here we start setting up a test platform to test our cross-compilation and explain some things about the architecture Raspberry Pi, where to find the ionformation when developing for Raspberry Pi 4.

#### QEMU testing 

qemu is able to simulate a Raspberry Pi3 and not a Raspberry Pi4, which are different when you're working in bare metal environment.

#### Raspberry Pi 3


#### Raspberry Pi 4
Cool we


Or just download the git-repo from TODO: ?????. The devtools will not be included in the repo.



To write the Assembler in A

- config.txt to support 64bit default.
- Architecture of the firmware/BIOS.

references:
(Pi3OS): https://github.com/bztsrc/raspi3-tutorial (accessed: 2020/11/29): The C part, where you can perdorm the testing and comparison
(BakingPiOS): https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/ (accessed: 2020/11/29): An introduction to playin with the Pi in assembly. 
(binutils): https://ftp.gnu.org/gnu/binutils/ (accessed: 2020/11/29): GNU binutiles for the assembler and linker for Aarch64 of GNU
(gcc) https://ftp.gnu.org/gnu/gcc/ (accessed: 2020/11/29): GNU CC compiler for C/C++ compiler
(GPIO) https://www.raspberrypi.org/documentation/usage/gpio/ (accessed: 2020/11/29): GPIO pin layout
- https://lowenware.com/blog/osdev/aarch64-bare-metal-program-in-rust/ (accessed: 2020/11/29): Nice explanation to install the Rust toolchain.
- https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2711/README.md (accessed: 2020/11/29): Click on 'here' to look at the datasheet.
- https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/README.md (accessed: 2020/11/29): Click 'Peripheral specification'. Isn't that for the Pi 1? You need it!
- https://modexp.wordpress.com/2018/10/30/arm64-assembly/ (accessed: 2020/11/29): Concised AArch64 overview, nicer then the 8248 pages Arm Architecture Reference Manual.
(ARMBible): https://developer.arm.com/docs/ddi0487/latest/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile (accessed: 2020/11/29): The 8248 pages Arm Architecture Reference Manual .
